# =============================================================================
# Workspace Configuration
# =============================================================================
# This workspace consolidates the rangebar Rust crates with Python bindings.
# All crates publish=false to prevent crates.io publishing.

[workspace]
resolver = "2"
members = [
    "crates/rangebar-core",
    "crates/rangebar-providers",
    "crates/rangebar-config",
    "crates/rangebar-io",
    "crates/rangebar-streaming",
    "crates/rangebar-batch",
    "crates/rangebar-cli",
    "crates/rangebar",
]

[workspace.package]
# CRITICAL: Prevent crates.io publishing - this is a PyPI-only project
publish = false
version = "12.10.0"
authors = ["Terry Li <terry@eonlabs.com>"]
categories = ["algorithms", "data-structures", "finance"]
documentation = "https://docs.rs/rangebar"
edition = "2024"
homepage = "https://github.com/terrylica/rangebar"
keywords = ["finance", "trading", "range-bars", "cryptocurrency", "binance"]
license = "MIT"
readme = "README.md"
repository = "https://github.com/terrylica/rangebar"
rust-version = "1.90"

[workspace.dependencies]
# Core dependencies (minimal)
serde = { version = "1.0", features = ["derive"] }
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "2.0"

# CLI dependencies
clap = { version = "4.0", features = ["derive", "env"] }
config = "0.14"

# Concurrency
rayon = "1.11"
tokio = { version = "1.0", features = ["full"] }
tokio-stream = "0.1"
async-trait = "0.1"
futures = "0.3"
futures-util = "0.3"

# HTTP/Network (rustls for cross-compilation - no OpenSSL dependency)
reqwest = { version = "0.12", default-features = false, features = ["stream", "rustls-tls"] }
tokio-tungstenite = { version = "0.23", default-features = false, features = ["rustls-tls-native-roots"] }

# Data formats
csv = "1.3"
zip = "2.2"
byteorder = "1.5.0"
lzma-rs = "0.3.0"
toml = "0.8"

# Data integrity
md5 = "0.7"
sha2 = "0.10"

# Analytics (optional)
polars = { version = "0.51.0", features = ["lazy", "temporal", "strings", "parquet", "csv", "ipc", "rolling_window"] }

# Arrow ecosystem (for streaming architecture)
# NOTE: pyo3-arrow 0.5.1 is the last version compatible with pyo3 0.22
# arrow 53.x is required by pyo3-arrow 0.5.1
arrow = "53"
arrow-array = "53"
arrow-schema = "53"
pyo3-arrow = "0.5.1"

# Streaming statistics (optional)
rolling-stats = "0.1"
tdigests = "1.0"

# Web framework (optional)
axum = { version = "0.7", features = ["json", "multipart", "ws"] }
tower = { version = "0.4", features = ["limit", "timeout"] }
tower-http = { version = "0.5", features = ["cors", "trace", "compression-br"] }
utoipa = { version = "4.2", features = ["axum_extras", "chrono", "uuid"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
validator = { version = "0.19", features = ["derive"] }
uuid = { version = "1.6", features = ["v4", "serde"] }

# Utilities
once_cell = "1.21"
num_cpus = "1.17"

# Dev dependencies
version-sync = "0.9"

# Benchmark dependencies
criterion = { version = "0.5", features = ["html_reports"] }

# =============================================================================
# PyO3 Extension Package
# =============================================================================

[package]
name = "rangebar-py"
version.workspace = true
edition = "2021"
authors = ["Terry Li"]
license = "MIT"
description = "Python bindings for rangebar: Non-lookahead range bar construction"
repository = "https://github.com/terrylica/rangebar-py"
readme = "README.md"
publish = false

[lib]
name = "rangebar_py"
crate-type = ["cdylib"]

[dependencies]
# Use PATH dependencies to internal crates (not crates.io)
rangebar-core = { path = "crates/rangebar-core" }
rangebar-providers = { path = "crates/rangebar-providers", optional = true, features = ["all-providers"] }
rangebar-streaming = { path = "crates/rangebar-streaming", optional = true }

# Async runtime for data fetching and streaming
tokio = { version = "1.0", features = ["rt-multi-thread"], optional = true }

# PyO3 for Python bindings
# NOTE: abi3 removed - pyo3-arrow requires buffer protocol (not in limited ABI)
# This means per-Python-version wheels instead of universal wheel
pyo3 = { version = "0.22", features = ["extension-module"] }

# Utilities
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Arrow ecosystem (streaming architecture)
arrow = { workspace = true, optional = true }
arrow-array = { workspace = true, optional = true }
arrow-schema = { workspace = true, optional = true }
pyo3-arrow = { workspace = true, optional = true }

[features]
# Default features: Include data-providers and arrow-export so PyPI users get the full API
default = ["data-providers", "arrow-export", "streaming"]
# Enable data fetching from all providers (Binance + Exness)
data-providers = ["rangebar-providers", "tokio"]
# Arrow export for streaming architecture (memory-efficient)
arrow-export = ["arrow", "arrow-array", "arrow-schema", "pyo3-arrow", "rangebar-core/arrow"]
# Real-time streaming support
streaming = ["rangebar-streaming", "rangebar-providers", "tokio"]
# Legacy feature aliases
exness = ["data-providers"]
binance = ["data-providers"]

[build-dependencies]
pyo3-build-config = "0.22"

[lints]
workspace = true

# =============================================================================
# Benchmarks
# =============================================================================

[[bench]]
name = "rangebar_bench"
harness = false

# =============================================================================
# Build Profiles
# =============================================================================
# CRITICAL: Do NOT use panic = "abort" with PyO3!
# PyO3 uses catch_unwind to convert Rust panics to Python exceptions.
# With panic = "abort", the process crashes instead of raising a Python exception.

[profile.release]
lto = "thin"           # Thin LTO for cross-platform compatibility
codegen-units = 1      # Maximum optimization (single codegen unit)
overflow-checks = false
# panic = "abort"      # FORBIDDEN with PyO3!

[profile.wheel]
inherits = "release"
lto = "thin"           # Thin LTO (safe for cross-compile)
codegen-units = 1      # Maximum optimization
strip = "symbols"      # Minimize wheel size

[profile.dev]
overflow-checks = true

# =============================================================================
# Clippy Lints (Workspace-level)
# =============================================================================

[workspace.lints.clippy]
# Lint group priority: lower number = lower priority (applied first)
all = { level = "deny", priority = -1 }
pedantic = { level = "warn", priority = -1 }
# nursery disabled - many false positives, focus on core correctness
# nursery = { level = "warn", priority = -1 }

# Allow certain lints that conflict with project style or PyO3 patterns
module_name_repetitions = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
needless_pass_by_value = "allow"  # PyO3 requires owned values for Python bindings
useless_conversion = "allow"      # PyO3 error handling patterns
upper_case_acronyms = "allow"     # Forex pairs use industry standard names (EURUSD, GBPUSD)
trivially_copy_pass_by_ref = "allow"  # PyO3 enum patterns
similar_names = "allow"           # ask/agg patterns in finance
cast_possible_truncation = "allow"    # Known-safe timestamp conversions
cast_sign_loss = "allow"          # Known-safe timestamp conversions
cast_precision_loss = "allow"     # Known-safe f64 timestamp conversions
cast_possible_wrap = "allow"      # index to i64 is safe within bounds
wildcard_imports = "allow"        # Module-level use super::* is idiomatic
use_self = "allow"                # Explicit type names in match arms for clarity
doc_markdown = "allow"            # Allow plain technical terms in docs
return_self_not_must_use = "allow"    # Builder pattern returns
collapsible_if = "allow"              # Nested if for clarity in complex conditions
manual_clamp = "allow"                # max().min() pattern is clear
items_after_statements = "allow"      # Local constants near usage
too_many_lines = "allow"              # PyO3 binding functions are naturally large
unnecessary_wraps = "allow"           # PyO3 requires PyResult even for infallible ops
significant_drop_tightening = "allow" # Lock guards need scope control
doc_link_with_quotes = "allow"        # Python dict syntax in docstrings
manual_range_contains = "allow"       # Explicit comparison for clarity
must_use_candidate = "allow"          # Too noisy - getters don't need #[must_use]
uninlined_format_args = "allow"       # format!("{}", x) is clear
cast_lossless = "allow"               # Explicit casts for clarity
map_unwrap_or = "allow"               # map().unwrap_or() pattern is common
unused_self = "allow"                 # Trait impls require self
cloned_instead_of_copied = "allow"    # cloned() is more explicit
if_not_else = "allow"                 # if !x is sometimes clearer
single_match_else = "allow"           # match with else is explicit
bool_to_int_with_if = "allow"         # if b { 1 } else { 0 } is clear
struct_excessive_bools = "allow"      # Config structs need bools
assigning_clones = "allow"            # clone() in assignment is clear
