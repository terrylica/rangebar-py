# =============================================================================
# Workspace Configuration
# =============================================================================
# This workspace consolidates the rangebar Rust crates with Python bindings.
# Published to crates.io: rangebar-core, rangebar-providers, rangebar-streaming
# Internal only (publish=false): rangebar-config, rangebar-io, rangebar-batch, rangebar-cli, rangebar

[workspace]
resolver = "2"
members = [
    "crates/rangebar-hurst",  # Internal MIT-licensed Hurst (GPL-3.0 conflict resolution)
    "crates/rangebar-core",
    "crates/rangebar-providers",
    "crates/rangebar-config",
    "crates/rangebar-io",
    "crates/rangebar-streaming",
    "crates/rangebar-batch",
    "crates/rangebar-cli",
    "crates/rangebar",
]

[workspace.package]
version = "12.27.0"
authors = ["Terry Li <terry@eonlabs.com>"]
categories = ["algorithms", "data-structures", "finance"]
documentation = "https://docs.rs/rangebar"
edition = "2024"
homepage = "https://github.com/terrylica/rangebar"
keywords = ["finance", "trading", "range-bars", "cryptocurrency", "binance"]
license = "MIT"
readme = "README.md"
repository = "https://github.com/terrylica/rangebar"
rust-version = "1.90"

[workspace.dependencies]
# Core dependencies (minimal)
serde = { version = "1.0", features = ["derive"] }
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "2.0"

# CLI dependencies
clap = { version = "4.0", features = ["derive", "env"] }
config = "0.14"

# Concurrency
rayon = "1.11"
tokio = { version = "1.0", features = ["full"] }
tokio-stream = "0.1"
tokio-util = { version = "0.7", features = ["rt"] }
async-trait = "0.1"
futures = "0.3"
futures-util = "0.3"

# HTTP/Network (rustls for cross-compilation - no OpenSSL dependency)
reqwest = { version = "0.12", default-features = false, features = ["stream", "rustls-tls", "json"] }
tokio-tungstenite = { version = "0.23", default-features = false, features = ["rustls-tls-native-roots"] }

# Data formats
csv = "1.3"
zip = "2.2"
byteorder = "1.5.0"
lzma-rs = "0.3.0"
toml = "0.8"

# Data integrity
md5 = "0.7"
sha2 = "0.10"

# Analytics (optional)
polars = { version = "0.51.0", features = ["lazy", "temporal", "strings", "parquet", "csv", "ipc", "rolling_window"] }

# Arrow ecosystem (for streaming architecture)
# NOTE: pyo3-arrow 0.5.1 is the last version compatible with pyo3 0.22
# arrow 53.x is required by pyo3-arrow 0.5.1
arrow = "53"
arrow-array = "53"
arrow-schema = "53"
pyo3-arrow = "0.5.1"

# Streaming statistics (optional)
rolling-stats = "0.1"
tdigests = "1.0"

# Web framework (optional)
axum = { version = "0.7", features = ["json", "multipart", "ws"] }
tower = { version = "0.4", features = ["limit", "timeout"] }
tower-http = { version = "0.5", features = ["cors", "trace", "compression-br"] }
utoipa = { version = "4.2", features = ["axum_extras", "chrono", "uuid"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
validator = { version = "0.19", features = ["derive"] }
uuid = { version = "1.6", features = ["v4", "serde"] }

# Utilities
once_cell = "1.21"
num_cpus = "1.17"
parking_lot = "0.12"

# Dev dependencies
version-sync = "0.9"

# Benchmark dependencies
criterion = { version = "0.5", features = ["html_reports"] }

# =============================================================================
# PyO3 Extension Package
# =============================================================================

[package]
name = "rangebar-py"
version.workspace = true
edition = "2021"
authors = ["Terry Li"]
license = "MIT"
description = "Python bindings for rangebar: Non-lookahead range bar construction"
repository = "https://github.com/terrylica/rangebar-py"
readme = "README.md"
publish = false

[lib]
name = "rangebar_py"
crate-type = ["cdylib"]

[dependencies]
# Use PATH dependencies to internal crates (not crates.io)
rangebar-core = { path = "crates/rangebar-core" }
rangebar-providers = { path = "crates/rangebar-providers", optional = true, features = ["all-providers"] }
rangebar-streaming = { path = "crates/rangebar-streaming", optional = true }

# Async runtime for data fetching and streaming
tokio = { version = "1.0", features = ["rt-multi-thread"], optional = true }
tokio-util = { workspace = true, optional = true }

# PyO3 for Python bindings
# NOTE: abi3 removed - pyo3-arrow requires buffer protocol (not in limited ABI)
# This means per-Python-version wheels instead of universal wheel
pyo3 = { version = "0.22", features = ["extension-module"] }

# Utilities
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
parking_lot = { workspace = true }

# Parallelism
rayon = { workspace = true }
num_cpus = { workspace = true }

# Arrow ecosystem (streaming architecture)
arrow = { workspace = true, optional = true }
arrow-array = { workspace = true, optional = true }
arrow-schema = { workspace = true, optional = true }
pyo3-arrow = { workspace = true, optional = true }

[features]
# Default features: Include data-providers and arrow-export so PyPI users get the full API
default = ["data-providers", "arrow-export", "streaming"]
# Enable data fetching from all providers (Binance + Exness)
data-providers = ["rangebar-providers", "tokio"]
# Arrow export for streaming architecture (memory-efficient)
arrow-export = ["arrow", "arrow-array", "arrow-schema", "pyo3-arrow", "rangebar-core/arrow"]
# Real-time streaming support (includes binance-integration for LiveBarEngine)
streaming = ["rangebar-streaming", "rangebar-streaming/binance-integration", "rangebar-providers", "tokio", "tokio-util"]
# Legacy feature aliases
exness = ["data-providers"]
binance = ["data-providers"]

[dev-dependencies]
criterion = { workspace = true }
rangebar = { path = "crates/rangebar" }
rangebar-hurst = { path = "crates/rangebar-hurst" }  # Issue #96 Task #149/150: GPL-3.0 conflict resolution

[build-dependencies]
rangebar-hurst = { path = "crates/rangebar-hurst" }  # Issue #96 Task #149/150: GPL-3.0 conflict resolution
pyo3-build-config = "0.22"

[lints]
workspace = true

# =============================================================================
# Benchmarks
# =============================================================================

[[bench]]
name = "rangebar_bench"
harness = false

[[bench]]
name = "profiling_analysis"
harness = false

[[bench]]
name = "concurrent_streaming_bench"
harness = false

[[bench]]
name = "kyle_lambda_profiling"
harness = false  # Issue #96 Task #148: Kyle Lambda profiling to determine SIMD viability

[[bench]]
name = "streaming_latency_profiler"
harness = false  # Issue #96 Task #144: Streaming latency profiling

[[bench]]
name = "feature_attribution_profiler"
harness = false  # Issue #96 Task #144 Phase 2: Feature attribution analysis

[[bench]]
name = "entropy_cache_comparison"
harness = false  # GitHub Issue #145: Multi-symbol entropy cache sharing benchmarks

[[bench]]
name = "tier1_optimization"
harness = false  # Issue #96 Task #153: Tier 1 inter-bar SIMD optimization baseline

[[bench]]
name = "interbar_cache_benchmark"
harness = false  # Issue #96 Task #144 Phase 4: Inter-bar feature result caching for streaming

[[bench]]
name = "vecdeque_pruning_benchmark"
harness = false  # Issue #96 Task #155: VecDeque adaptive pruning optimization

[[bench]]
name = "entropy_cache_trylock_benchmark"
harness = false  # Issue #96 Task #156: Entropy cache try-lock fast-path optimization

[[bench]]
name = "allocator_tuning_benchmark"
harness = false  # Issue #96 Task #158: Allocator buffer size tuning (post-Phase 9)

[[bench]]
name = "pe_threshold_tuning_benchmark"
harness = false  # Issue #96 Task #157: PE threshold optimization for real workloads

[[bench]]
name = "zero_copy_trade_snapshot_benchmark"
harness = false  # Issue #96 Task #159: Zero-copy trade snapshot optimization analysis

[[bench]]
name = "hurst_early_exit_benchmark"
harness = false  # Issue #96 Task #160: Hurst early-exit via entropy threshold

[[bench]]
name = "apen_simd_optimization_benchmark"
harness = false  # Issue #96 Task #161: ApEn SIMD optimization analysis

[[bench]]
name = "intrabar_dual_pass_benchmark"
harness = false  # Issue #96 Task #166: Intra-bar dual-pass elimination optimization

[[bench]]
name = "normalization_lut_benchmark"
harness = false  # Issue #96 Task #197: Normalization LUT (sigmoid/tanh) optimization

# =============================================================================
# Build Profiles
# =============================================================================
# CRITICAL: Do NOT use panic = "abort" with PyO3!
# PyO3 uses catch_unwind to convert Rust panics to Python exceptions.
# With panic = "abort", the process crashes instead of raising a Python exception.

[profile.release]
lto = "thin"           # Thin LTO for cross-platform compatibility
codegen-units = 1      # Maximum optimization (single codegen unit)
opt-level = 3          # Explicit maximum optimization
overflow-checks = false
# panic = "abort"      # FORBIDDEN with PyO3!

[profile.wheel]
inherits = "release"
lto = "thin"           # Thin LTO (safe for cross-compile)
codegen-units = 1      # Maximum optimization
strip = "symbols"      # Minimize wheel size

[profile.pgo-collect]
inherits = "release"
lto = "thin"
codegen-units = 1
opt-level = 3
# RUSTFLAGS needed for PGO collection: -Cprofile-generate=/path/to/pgo-data
# Compile with: RUSTFLAGS='-Cprofile-generate=./pgo-data' cargo build -p rangebar-py --release --profile pgo-collect

[profile.pgo-use]
inherits = "release"
lto = "thin"
codegen-units = 1
opt-level = 3
# RUSTFLAGS needed for PGO optimization: -Cprofile-use=/path/to/pgo-data/merged.profdata,-Cllvm-args=-pgo-warn-missing-function
# Compile with: RUSTFLAGS='-Cprofile-use=./pgo-data/merged.profdata -Cllvm-args=-pgo-warn-missing-function' cargo build -p rangebar-py --release --profile pgo-use

[profile.dev]
overflow-checks = true

# =============================================================================
# Clippy Lints (Workspace-level)
# =============================================================================

[workspace.lints.clippy]
# Lint group priority: lower number = lower priority (applied first)
all = { level = "deny", priority = -1 }
pedantic = { level = "warn", priority = -1 }
# nursery disabled - many false positives, focus on core correctness
# nursery = { level = "warn", priority = -1 }

# Allow certain lints that conflict with project style or PyO3 patterns
module_name_repetitions = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
needless_pass_by_value = "allow"  # PyO3 requires owned values for Python bindings
useless_conversion = "allow"      # PyO3 error handling patterns
upper_case_acronyms = "allow"     # Forex pairs use industry standard names (EURUSD, GBPUSD)
trivially_copy_pass_by_ref = "allow"  # PyO3 enum patterns
similar_names = "allow"           # ask/agg patterns in finance
cast_possible_truncation = "allow"    # Known-safe timestamp conversions
cast_sign_loss = "allow"          # Known-safe timestamp conversions
cast_precision_loss = "allow"     # Known-safe f64 timestamp conversions
cast_possible_wrap = "allow"      # index to i64 is safe within bounds
wildcard_imports = "allow"        # Module-level use super::* is idiomatic
use_self = "allow"                # Explicit type names in match arms for clarity
doc_markdown = "allow"            # Allow plain technical terms in docs
return_self_not_must_use = "allow"    # Builder pattern returns
collapsible_if = "allow"              # Nested if for clarity in complex conditions
manual_clamp = "allow"                # max().min() pattern is clear
items_after_statements = "allow"      # Local constants near usage
too_many_lines = "allow"              # PyO3 binding functions are naturally large
unnecessary_wraps = "allow"           # PyO3 requires PyResult even for infallible ops
significant_drop_tightening = "allow" # Lock guards need scope control
doc_link_with_quotes = "allow"        # Python dict syntax in docstrings
manual_range_contains = "allow"       # Explicit comparison for clarity
must_use_candidate = "allow"          # Too noisy - getters don't need #[must_use]
uninlined_format_args = "allow"       # format!("{}", x) is clear
cast_lossless = "allow"               # Explicit casts for clarity
map_unwrap_or = "allow"               # map().unwrap_or() pattern is common
unused_self = "allow"                 # Trait impls require self
cloned_instead_of_copied = "allow"    # cloned() is more explicit
if_not_else = "allow"                 # if !x is sometimes clearer
single_match_else = "allow"           # match with else is explicit
bool_to_int_with_if = "allow"         # if b { 1 } else { 0 } is clear
struct_excessive_bools = "allow"      # Config structs need bools
assigning_clones = "allow"            # clone() in assignment is clear
